定义一个类时，默认/自己定义 此类型对象的拷贝，移动，赋值，销毁的行为。 
拷贝构造函数：
拷贝赋值运算符：
移动构造函数：
移动赋值运算符：
析构函数：

## 13.1 拷贝，赋值，销毁
 ### 拷贝构造函数
 构造函数的第一个参数是自身类的引用，其他参数都有默认值
 且几乎总是一个const **引用**，拷贝构造函数不应该声明explicit；（explicit只能直接初始化）
 ### 合成拷贝构造函数
 如果没声明，编译器会为他生成一个，会将成员逐个拷贝到正在构建的对象中（非static，因为static不用赋值）
 ### 拷贝初始化
 直接初始化：直接参数匹配（构造函数的参数匹配）
 拷贝初始化：对象的拷贝
 拷贝初始化通常使用拷贝构造函数完成
 拷贝初始化发生的情况：
 对象（类）的非引用的参数传递；
 非引用对象作为返回值；
 花括号列表初始化；
 emplace是直接初始化，其他是拷贝初始化

### 为什么拷贝构造的参数必须为引用？
因为如果不引用，类对象作为参数传递会发生一次拷贝，而此次拷贝又会调用拷贝构造函数，无限循环。

### 拷贝赋值运算符
重载运算符本质上是一个函数，那么赋值运算符 = 就是一个**名字为operator=的函数**。

### 合成拷贝赋值运算符
将右侧对象成员赋值给左侧对象成员；\
赋值运算符通常返回一个纸箱其左侧运算符的引用；

## 析构函数
·
##使用delete阻止拷贝
```c++
struct NoCopy{
    NoCopy() = default;//使用default要求编译器自动生成
    NoCopy(const NoCopy&)=delete //阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete;
    ~NoCopy()=default;//自动生成析构函数
}
```
析构函数不能``` = delete```，如果定义为delete，就不能delete这个对象了

### 让类的行为像指针--像shared_ptr一样
